-- Create Profiles Table
-- This table stores public user data.
create table profiles (
  id uuid references auth.users not null primary key,
  updated_at timestamp with time zone,
  full_name text,
  avatar_url text,
  bio text,
  skills text[],
  credits integer default 20,
  reputation_score integer default 50
);

-- RLS for Profiles
alter table profiles enable row level security;
create policy "Public profiles are viewable by everyone." on profiles for select using (true);
create policy "Users can insert their own profile." on profiles for insert with check (auth.uid() = id);
create policy "Users can update own profile." on profiles for update using (auth.uid() = id);

-- Create a trigger to automatically create a profile when a new user signs up.
create function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, full_name, avatar_url)
  values (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
  return new;
end;
$$ language plpgsql security definer;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();


-- Create Tests Table
-- This table stores all the tests created by users.
create table tests (
    id bigint generated by default as identity primary key,
    user_id uuid references profiles not null,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null,
    title text not null,
    description text,
    category text,
    estimated_time integer, -- in minutes
    max_testers integer,
    reward_credits integer not null check (reward_credits >= 5),
    instructions jsonb,
    proof_method text default 'form', -- 'form' or 'manual'
    questions jsonb,
    status text default 'open' -- 'open', 'closed', 'archived'
);

-- RLS for Tests
alter table tests enable row level security;
create policy "Tests are viewable by everyone." on tests for select using (true);
create policy "Users can insert their own tests." on tests for insert with check (auth.uid() = user_id);
create policy "Users can update their own tests." on tests for update using (auth.uid() = user_id);
create policy "Users can delete their own tests." on tests for delete using (auth.uid() = user_id);

-- Create Test Submissions Table
-- This table stores submissions from testers for each test.
create table test_submissions (
    id bigint generated by default as identity primary key,
    test_id bigint references tests not null,
    user_id uuid references profiles not null,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null,
    status text default 'pending', -- 'pending', 'approved', 'rejected'
    feedback jsonb,
    file_proof_url text,
    unique(test_id, user_id) -- Ensures a user can only submit once per test
);

-- RLS for Test Submissions
alter table test_submissions enable row level security;
create policy "Users can view their own submissions." on test_submissions for select using (auth.uid() = user_id);
create policy "Posters can view submissions for their tests." on test_submissions for select using (
    exists (
        select 1 from tests where tests.id = test_submissions.test_id and tests.user_id = auth.uid()
    )
);
create policy "Users can insert their own submissions." on test_submissions for insert with check (auth.uid() = user_id);
create policy "Posters can update submission status for their tests." on test_submissions for update using (
    exists (
        select 1 from tests where tests.id = test_submissions.test_id and tests.user_id = auth.uid()
    )
);


-- Create Credit Transactions Table
-- This table logs all credit movements.
create table credit_transactions (
    id bigint generated by default as identity primary key,
    user_id uuid references profiles not null,
    amount integer not null,
    description text,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null,
    test_id bigint references tests
);

-- RLS for Credit Transactions
alter table credit_transactions enable row level security;
create policy "Users can view their own transactions." on credit_transactions for select using (auth.uid() = user_id);


-- DB Function for Atomic Credit Transfer
create or replace function approve_submission_and_transfer_credits(p_submission_id bigint)
returns void as $$
declare
  v_test_id bigint;
  v_poster_id uuid;
  v_tester_id uuid;
  v_reward integer;
begin
  -- 1. Get submission details
  select test_id, user_id into v_test_id, v_tester_id
  from public.test_submissions
  where id = p_submission_id;

  -- 2. Get test details
  select user_id, reward_credits into v_poster_id, v_reward
  from public.tests
  where id = v_test_id;

  -- Security check: Ensure the caller is the poster
  if v_poster_id != auth.uid() then
    raise exception 'User is not authorized to approve this submission.';
  end if;

  -- 3. Update submission status
  update public.test_submissions
  set status = 'approved'
  where id = p_submission_id;

  -- 4. Deduct credits from poster
  update public.profiles
  set credits = credits - v_reward
  where id = v_poster_id;

  -- 5. Add credits to tester
  update public.profiles
  set credits = credits + v_reward
  where id = v_tester_id;

  -- 6. Log poster's transaction
  insert into public.credit_transactions (user_id, amount, description, test_id)
  values (v_poster_id, -v_reward, 'Paid for approved submission', v_test_id);
  
  -- 7. Log tester's transaction
  insert into public.credit_transactions (user_id, amount, description, test_id)
  values (v_tester_id, v_reward, 'Earned from approved submission', v_test_id);

end;
$$ language plpgsql security definer;
